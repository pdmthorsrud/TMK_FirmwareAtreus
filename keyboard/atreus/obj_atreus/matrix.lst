   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB18:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #   define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // initialize row and col
  61:matrix.c      ****     unselect_rows();
  62:matrix.c      ****     init_cols();
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize matrix state: all keys off
  65:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  66:matrix.c      ****         matrix[i] = 0;
  67:matrix.c      ****         matrix_debouncing[i] = 0;
  68:matrix.c      ****     }
  69:matrix.c      **** }
  70:matrix.c      **** 
  71:matrix.c      **** uint8_t matrix_scan(void)
  72:matrix.c      **** {
  73:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  74:matrix.c      ****         select_row(i);
  75:matrix.c      ****         _delay_us(50);  // without this wait read unstable value.
  76:matrix.c      ****         matrix_row_t cols = read_cols();
  77:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  78:matrix.c      ****             matrix_debouncing[i] = cols;
  79:matrix.c      ****             if (debouncing) {
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  81:matrix.c      ****             }
  82:matrix.c      ****             debouncing = DEBOUNCE;
  83:matrix.c      ****         }
  84:matrix.c      ****         unselect_rows();
  85:matrix.c      ****     }
  86:matrix.c      **** 
  87:matrix.c      ****     if (debouncing) {
  88:matrix.c      ****         if (--debouncing) {
  89:matrix.c      ****             _delay_ms(1);
  90:matrix.c      ****         } else {
  91:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  92:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  93:matrix.c      ****             }
  94:matrix.c      ****         }
  95:matrix.c      ****     }
  96:matrix.c      **** 
  97:matrix.c      ****     return 1;
  98:matrix.c      **** }
  99:matrix.c      **** 
 100:matrix.c      **** bool matrix_is_modified(void)
 101:matrix.c      **** {
 102:matrix.c      ****     if (debouncing) return false;
 103:matrix.c      ****     return true;
 104:matrix.c      **** }
 105:matrix.c      **** 
 106:matrix.c      **** inline
 107:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 108:matrix.c      **** {
 109:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 110:matrix.c      **** }
 111:matrix.c      **** 
 112:matrix.c      **** inline
 113:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 114:matrix.c      **** {
 115:matrix.c      ****     return matrix[row];
 116:matrix.c      **** }
 117:matrix.c      **** 
 118:matrix.c      **** void matrix_print(void)
 119:matrix.c      **** {
 120:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 121:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 122:matrix.c      ****         phex(row); print(": ");
 123:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 124:matrix.c      ****         print("\n");
 125:matrix.c      ****     }
 126:matrix.c      **** }
 127:matrix.c      **** 
 128:matrix.c      **** uint8_t matrix_key_count(void)
 129:matrix.c      **** {
 130:matrix.c      ****     uint8_t count = 0;
 131:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 132:matrix.c      ****         count += bitpop16(matrix[i]);
 133:matrix.c      ****     }
 134:matrix.c      ****     return count;
 135:matrix.c      **** }
 136:matrix.c      **** 
 137:matrix.c      **** /* Column pin configuration
 138:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   10
 139:matrix.c      ****  * pin: B7  D6  F7  F6  B6  D4  E6  B4  B5  C6  D7
 140:matrix.c      ****  */
 141:matrix.c      **** static void  init_cols(void)
 142:matrix.c      **** {
 143:matrix.c      ****   // Input with pull-up(DDR:0, PORT:1)
 144:matrix.c      ****   DDRF  &= ~(1<<1 | 1<<4 | 1<<5 | 1<<6);
 145:matrix.c      ****   PORTF |=  (1<<1 | 1<<4 | 1<<5 | 1<<6);
 146:matrix.c      ****   DDRB  &= ~(1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 147:matrix.c      ****   PORTB |=  (1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 148:matrix.c      **** }
 149:matrix.c      **** 
 150:matrix.c      **** static matrix_row_t read_cols(void)
 151:matrix.c      **** {
 152:matrix.c      **** #ifdef TEENSY
 153:matrix.c      ****     return (PINF&(1<<6) ? 0 : (1<<0)) |
 154:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 155:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 156:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 157:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 158:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 159:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 160:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 161:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 162:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 163:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<10)) ;
 164:matrix.c      **** #else
 165:matrix.c      ****     return (PINF&(1<<6) ? 0 : (1<<0)) |
 166:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 167:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 168:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 169:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 170:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 171:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 172:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 173:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 174:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 175:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<10)) ;
 176:matrix.c      **** #endif
 177:matrix.c      **** }
 178:matrix.c      **** 
 179:matrix.c      **** /* Row pin configuration
 180:matrix.c      ****  * row: 0   1   2   3
 181:matrix.c      ****  * pin: D0  D1  D3  D2    (a-star micro)
 182:matrix.c      ****  * pin: D0  D1  D2  D3    (teensy2)
 183:matrix.c      ****  */
 184:matrix.c      **** static void unselect_rows(void)
 185:matrix.c      **** {
  15               		.loc 1 185 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 186:matrix.c      ****   // Hi-Z(DDR:0, PORT:0) to unselect
 187:matrix.c      ****   DDRD  &= ~0b00001111;
  21               		.loc 1 187 0
  22 0000 8AB1      		in r24,0xa
  23 0002 807F      		andi r24,lo8(-16)
  24 0004 8AB9      		out 0xa,r24
 188:matrix.c      ****   PORTD &= ~0b00001111;
  25               		.loc 1 188 0
  26 0006 8BB1      		in r24,0xb
  27 0008 807F      		andi r24,lo8(-16)
  28 000a 8BB9      		out 0xb,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE18:
  33               		.section	.text.matrix_rows,"ax",@progbits
  34               	.global	matrix_rows
  36               	matrix_rows:
  37               	.LFB7:
  48:matrix.c      ****     return MATRIX_ROWS;
  38               		.loc 1 48 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
  50:matrix.c      **** 
  44               		.loc 1 50 0
  45 0000 84E0      		ldi r24,lo8(4)
  46 0002 0895      		ret
  47               		.cfi_endproc
  48               	.LFE7:
  50               		.section	.text.matrix_cols,"ax",@progbits
  51               	.global	matrix_cols
  53               	matrix_cols:
  54               	.LFB8:
  54:matrix.c      ****     return MATRIX_COLS;
  55               		.loc 1 54 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  56:matrix.c      **** 
  61               		.loc 1 56 0
  62 0000 8BE0      		ldi r24,lo8(11)
  63 0002 0895      		ret
  64               		.cfi_endproc
  65               	.LFE8:
  67               		.section	.text.matrix_init,"ax",@progbits
  68               	.global	matrix_init
  70               	matrix_init:
  71               	.LFB9:
  59:matrix.c      ****     // initialize row and col
  72               		.loc 1 59 0
  73               		.cfi_startproc
  74               	/* prologue: function */
  75               	/* frame size = 0 */
  76               	/* stack size = 0 */
  77               	.L__stack_usage = 0
  61:matrix.c      ****     init_cols();
  78               		.loc 1 61 0
  79 0000 0E94 0000 		call unselect_rows
  80               	.LVL0:
  81               	.LBB23:
  82               	.LBB24:
 144:matrix.c      ****   PORTF |=  (1<<1 | 1<<4 | 1<<5 | 1<<6);
  83               		.loc 1 144 0
  84 0004 80B3      		in r24,0x10
  85 0006 8D78      		andi r24,lo8(-115)
  86 0008 80BB      		out 0x10,r24
 145:matrix.c      ****   DDRB  &= ~(1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
  87               		.loc 1 145 0
  88 000a 81B3      		in r24,0x11
  89 000c 8267      		ori r24,lo8(114)
  90 000e 81BB      		out 0x11,r24
 146:matrix.c      ****   PORTB |=  (1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
  91               		.loc 1 146 0
  92 0010 84B1      		in r24,0x4
  93 0012 8170      		andi r24,lo8(1)
  94 0014 84B9      		out 0x4,r24
 147:matrix.c      **** }
  95               		.loc 1 147 0
  96 0016 85B1      		in r24,0x5
  97 0018 8E6F      		ori r24,lo8(-2)
  98 001a 85B9      		out 0x5,r24
  99               	.LVL1:
 100               	.LBE24:
 101               	.LBE23:
 102               	.LBB25:
  66:matrix.c      ****         matrix_debouncing[i] = 0;
 103               		.loc 1 66 0
 104 001c A0E0      		ldi r26,lo8(matrix)
 105 001e B0E0      		ldi r27,hi8(matrix)
 106 0020 1196      		adiw r26,1
 107 0022 1C92      		st X,__zero_reg__
 108 0024 1E92      		st -X,__zero_reg__
  67:matrix.c      ****     }
 109               		.loc 1 67 0
 110 0026 E0E0      		ldi r30,lo8(matrix_debouncing)
 111 0028 F0E0      		ldi r31,hi8(matrix_debouncing)
 112 002a 1182      		std Z+1,__zero_reg__
 113 002c 1082      		st Z,__zero_reg__
 114               	.LVL2:
  66:matrix.c      ****         matrix_debouncing[i] = 0;
 115               		.loc 1 66 0
 116 002e 1396      		adiw r26,2+1
 117 0030 1C92      		st X,__zero_reg__
 118 0032 1E92      		st -X,__zero_reg__
 119 0034 1297      		sbiw r26,2
  67:matrix.c      ****     }
 120               		.loc 1 67 0
 121 0036 1382      		std Z+3,__zero_reg__
 122 0038 1282      		std Z+2,__zero_reg__
 123               	.LVL3:
  66:matrix.c      ****         matrix_debouncing[i] = 0;
 124               		.loc 1 66 0
 125 003a 1596      		adiw r26,4+1
 126 003c 1C92      		st X,__zero_reg__
 127 003e 1E92      		st -X,__zero_reg__
 128 0040 1497      		sbiw r26,4
  67:matrix.c      ****     }
 129               		.loc 1 67 0
 130 0042 1582      		std Z+5,__zero_reg__
 131 0044 1482      		std Z+4,__zero_reg__
 132               	.LVL4:
  66:matrix.c      ****         matrix_debouncing[i] = 0;
 133               		.loc 1 66 0
 134 0046 1796      		adiw r26,6+1
 135 0048 1C92      		st X,__zero_reg__
 136 004a 1E92      		st -X,__zero_reg__
 137 004c 1697      		sbiw r26,6
  67:matrix.c      ****     }
 138               		.loc 1 67 0
 139 004e 1782      		std Z+7,__zero_reg__
 140 0050 1682      		std Z+6,__zero_reg__
 141               	.LVL5:
 142 0052 0895      		ret
 143               	.LBE25:
 144               		.cfi_endproc
 145               	.LFE9:
 147               		.section	.text.matrix_scan,"ax",@progbits
 148               	.global	matrix_scan
 150               	matrix_scan:
 151               	.LFB10:
  72:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 152               		.loc 1 72 0
 153               		.cfi_startproc
 154 0000 BF92      		push r11
 155               	.LCFI0:
 156               		.cfi_def_cfa_offset 3
 157               		.cfi_offset 11, -2
 158 0002 CF92      		push r12
 159               	.LCFI1:
 160               		.cfi_def_cfa_offset 4
 161               		.cfi_offset 12, -3
 162 0004 DF92      		push r13
 163               	.LCFI2:
 164               		.cfi_def_cfa_offset 5
 165               		.cfi_offset 13, -4
 166 0006 EF92      		push r14
 167               	.LCFI3:
 168               		.cfi_def_cfa_offset 6
 169               		.cfi_offset 14, -5
 170 0008 FF92      		push r15
 171               	.LCFI4:
 172               		.cfi_def_cfa_offset 7
 173               		.cfi_offset 15, -6
 174 000a 0F93      		push r16
 175               	.LCFI5:
 176               		.cfi_def_cfa_offset 8
 177               		.cfi_offset 16, -7
 178 000c 1F93      		push r17
 179               	.LCFI6:
 180               		.cfi_def_cfa_offset 9
 181               		.cfi_offset 17, -8
 182 000e CF93      		push r28
 183               	.LCFI7:
 184               		.cfi_def_cfa_offset 10
 185               		.cfi_offset 28, -9
 186 0010 DF93      		push r29
 187               	.LCFI8:
 188               		.cfi_def_cfa_offset 11
 189               		.cfi_offset 29, -10
 190               	/* prologue: function */
 191               	/* frame size = 0 */
 192               	/* stack size = 9 */
 193               	.L__stack_usage = 9
 194               	.LVL6:
 195 0012 C0E0      		ldi r28,lo8(matrix_debouncing)
 196 0014 D0E0      		ldi r29,hi8(matrix_debouncing)
 197               	.LBB40:
  73:matrix.c      ****         select_row(i);
 198               		.loc 1 73 0
 199 0016 D12C      		mov r13,__zero_reg__
 200               	.LBB41:
 201               	.LBB42:
 202               	.LBB43:
 165:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 203               		.loc 1 165 0
 204 0018 CC24      		clr r12
 205 001a C394      		inc r12
 206               	.LBE43:
 207               	.LBE42:
  82:matrix.c      ****         }
 208               		.loc 1 82 0
 209 001c 45E0      		ldi r20,lo8(5)
 210 001e B42E      		mov r11,r20
  80:matrix.c      ****             }
 211               		.loc 1 80 0
 212 0020 50E0      		ldi r21,lo8(__c.1909)
 213 0022 E52E      		mov r14,r21
 214 0024 50E0      		ldi r21,hi8(__c.1909)
 215 0026 F52E      		mov r15,r21
 216               	.LVL7:
 217               	.L27:
 218               	.LBB45:
 219               	.LBB46:
 189:matrix.c      **** }
 190:matrix.c      **** 
 191:matrix.c      **** #define ROW_COUNT 4
 192:matrix.c      **** #ifdef TEENSY
 193:matrix.c      **** int rows[ROW_COUNT] = {0, 1, 2, 3};
 194:matrix.c      **** #else
 195:matrix.c      **** int rows[ROW_COUNT] = {0, 1, 3, 2};
 196:matrix.c      **** #endif
 197:matrix.c      **** 
 198:matrix.c      **** static void select_row(uint8_t row)
 199:matrix.c      **** {
 200:matrix.c      ****   // Output low(DDR:1, PORT:0) to select
 201:matrix.c      ****   switch (row) {
 220               		.loc 1 201 0
 221 0028 82E0      		ldi r24,lo8(2)
 222 002a D816      		cp r13,r24
 223 002c 01F0      		breq .L7
 224 002e 93E0      		ldi r25,lo8(3)
 225 0030 D916      		cp r13,r25
 226 0032 01F0      		breq .L8
 227 0034 81E0      		ldi r24,lo8(1)
 228 0036 D816      		cp r13,r24
 229 0038 01F0      		breq .L9
 202:matrix.c      ****       case 0:
 203:matrix.c      ****           DDRD  |= (1<<0);
 230               		.loc 1 203 0
 231 003a 509A      		sbi 0xa,0
 204:matrix.c      ****           PORTD &= ~(1<<0);
 232               		.loc 1 204 0
 233 003c 5898      		cbi 0xb,0
 234 003e 00C0      		rjmp .L10
 235               	.L9:
 205:matrix.c      ****           break;
 206:matrix.c      ****       case 1:
 207:matrix.c      ****           DDRD  |= (1<<1);
 236               		.loc 1 207 0
 237 0040 519A      		sbi 0xa,1
 208:matrix.c      ****           PORTD &= ~(1<<1);
 238               		.loc 1 208 0
 239 0042 5998      		cbi 0xb,1
 240 0044 00C0      		rjmp .L10
 241               	.L7:
 209:matrix.c      ****           break;
 210:matrix.c      ****       case 2:
 211:matrix.c      ****           DDRD  |= (1<<2);
 242               		.loc 1 211 0
 243 0046 529A      		sbi 0xa,2
 212:matrix.c      ****           PORTD &= ~(1<<2);
 244               		.loc 1 212 0
 245 0048 5A98      		cbi 0xb,2
 246 004a 00C0      		rjmp .L10
 247               	.L8:
 213:matrix.c      ****           break;
 214:matrix.c      ****       case 3:
 215:matrix.c      ****           DDRD  |= (1<<3);
 248               		.loc 1 215 0
 249 004c 539A      		sbi 0xa,3
 216:matrix.c      ****           PORTD &= ~(1<<3);
 250               		.loc 1 216 0
 251 004e 5B98      		cbi 0xb,3
 252               	.L10:
 253               	.LVL8:
 254               	.LBE46:
 255               	.LBE45:
 256               	.LBB47:
 257               	.LBB48:
 258               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 259               		.loc 2 245 0
 260 0050 87EC      		ldi r24,lo8(199)
 261 0052 90E0      		ldi r25,hi8(199)
 262 0054 0197      	1:	sbiw r24,1
 263 0056 01F4      		brne 1b
 264 0058 00C0      		rjmp .
 265 005a 0000      		nop
 266               	.LBE48:
 267               	.LBE47:
 268               	.LBB49:
 269               	.LBB44:
 165:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 270               		.loc 1 165 0
 271 005c 8FB1      		in r24,0xf
 272 005e 8295      		swap r24
 273 0060 8695      		lsr r24
 274 0062 8695      		lsr r24
 275 0064 8370      		andi r24,lo8(3)
 276 0066 8C25      		eor r24,r12
 277 0068 082F      		mov r16,r24
 278 006a 0170      		andi r16,1
 279 006c 10E0      		ldi r17,0
 166:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 280               		.loc 1 166 0
 281 006e 7D99      		sbic 0xf,5
 282 0070 00C0      		rjmp .L32
 283 0072 22E0      		ldi r18,lo8(2)
 284 0074 30E0      		ldi r19,0
 285 0076 00C0      		rjmp .L11
 286               	.L32:
 287 0078 20E0      		ldi r18,0
 288 007a 30E0      		ldi r19,0
 289               	.L11:
 165:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 290               		.loc 1 165 0
 291 007c C901      		movw r24,r18
 292 007e 802B      		or r24,r16
 293 0080 912B      		or r25,r17
 167:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 294               		.loc 1 167 0
 295 0082 7C99      		sbic 0xf,4
 296 0084 00C0      		rjmp .L33
 297 0086 24E0      		ldi r18,lo8(4)
 298 0088 30E0      		ldi r19,0
 299 008a 00C0      		rjmp .L12
 300               	.L33:
 301 008c 20E0      		ldi r18,0
 302 008e 30E0      		ldi r19,0
 303               	.L12:
 166:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 304               		.loc 1 166 0
 305 0090 AC01      		movw r20,r24
 306 0092 422B      		or r20,r18
 307 0094 532B      		or r21,r19
 168:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 308               		.loc 1 168 0
 309 0096 23B1      		in r18,0x3
 310 0098 022E      		mov __tmp_reg__,r18
 311 009a 000C      		lsl r0
 312 009c 330B      		sbc r19,r19
 313 009e 2095      		com r18
 314 00a0 3095      		com r19
 315 00a2 C901      		movw r24,r18
 316 00a4 8827      		clr r24
 317 00a6 990F      		lsl r25
 318 00a8 881F      		rol r24
 319 00aa 9927      		clr r25
 320 00ac 33E0      		ldi r19,3
 321               		1:
 322 00ae 880F      		lsl r24
 323 00b0 991F      		rol r25
 324 00b2 3A95      		dec r19
 325 00b4 01F4      		brne 1b
 167:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 326               		.loc 1 167 0
 327 00b6 842B      		or r24,r20
 328 00b8 952B      		or r25,r21
 169:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 329               		.loc 1 169 0
 330 00ba 1E99      		sbic 0x3,6
 331 00bc 00C0      		rjmp .L35
 332 00be 40E1      		ldi r20,lo8(16)
 333 00c0 50E0      		ldi r21,0
 334 00c2 00C0      		rjmp .L14
 335               	.L35:
 336 00c4 40E0      		ldi r20,0
 337 00c6 50E0      		ldi r21,0
 338               	.L14:
 168:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 339               		.loc 1 168 0
 340 00c8 842B      		or r24,r20
 341 00ca 952B      		or r25,r21
 170:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 342               		.loc 1 170 0
 343 00cc 1D99      		sbic 0x3,5
 344 00ce 00C0      		rjmp .L36
 345 00d0 40E2      		ldi r20,lo8(32)
 346 00d2 50E0      		ldi r21,0
 347 00d4 00C0      		rjmp .L15
 348               	.L36:
 349 00d6 40E0      		ldi r20,0
 350 00d8 50E0      		ldi r21,0
 351               	.L15:
 169:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 352               		.loc 1 169 0
 353 00da 842B      		or r24,r20
 354 00dc 952B      		or r25,r21
 171:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 355               		.loc 1 171 0
 356 00de 1C99      		sbic 0x3,4
 357 00e0 00C0      		rjmp .L37
 358 00e2 20E4      		ldi r18,lo8(64)
 359 00e4 30E0      		ldi r19,0
 360 00e6 00C0      		rjmp .L16
 361               	.L37:
 362 00e8 20E0      		ldi r18,0
 363 00ea 30E0      		ldi r19,0
 364               	.L16:
 170:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 365               		.loc 1 170 0
 366 00ec 822B      		or r24,r18
 367 00ee 932B      		or r25,r19
 172:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 368               		.loc 1 172 0
 369 00f0 1B99      		sbic 0x3,3
 370 00f2 00C0      		rjmp .L38
 371 00f4 60E8      		ldi r22,lo8(-128)
 372 00f6 70E0      		ldi r23,0
 373 00f8 00C0      		rjmp .L17
 374               	.L38:
 375 00fa 60E0      		ldi r22,0
 376 00fc 70E0      		ldi r23,0
 377               	.L17:
 171:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 378               		.loc 1 171 0
 379 00fe 862B      		or r24,r22
 380 0100 972B      		or r25,r23
 173:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 381               		.loc 1 173 0
 382 0102 1A99      		sbic 0x3,2
 383 0104 00C0      		rjmp .L39
 384 0106 40E0      		ldi r20,0
 385 0108 51E0      		ldi r21,lo8(1)
 386 010a 00C0      		rjmp .L18
 387               	.L39:
 388 010c 40E0      		ldi r20,0
 389 010e 50E0      		ldi r21,0
 390               	.L18:
 172:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 391               		.loc 1 172 0
 392 0110 842B      		or r24,r20
 393 0112 952B      		or r25,r21
 174:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<10)) ;
 394               		.loc 1 174 0
 395 0114 1999      		sbic 0x3,1
 396 0116 00C0      		rjmp .L40
 397 0118 20E0      		ldi r18,0
 398 011a 32E0      		ldi r19,lo8(2)
 399 011c 00C0      		rjmp .L19
 400               	.L40:
 401 011e 20E0      		ldi r18,0
 402 0120 30E0      		ldi r19,0
 403               	.L19:
 173:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 404               		.loc 1 173 0
 405 0122 822B      		or r24,r18
 406 0124 932B      		or r25,r19
 175:matrix.c      **** #endif
 407               		.loc 1 175 0
 408 0126 7999      		sbic 0xf,1
 409 0128 00C0      		rjmp .L41
 410 012a 20E0      		ldi r18,0
 411 012c 34E0      		ldi r19,lo8(4)
 412 012e 00C0      		rjmp .L20
 413               	.L41:
 414 0130 20E0      		ldi r18,0
 415 0132 30E0      		ldi r19,0
 416               	.L20:
 174:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<10)) ;
 417               		.loc 1 174 0
 418 0134 822B      		or r24,r18
 419 0136 932B      		or r25,r19
 420               	.LBE44:
 421               	.LBE49:
  77:matrix.c      ****             matrix_debouncing[i] = cols;
 422               		.loc 1 77 0
 423 0138 2881      		ld r18,Y
 424 013a 3981      		ldd r19,Y+1
 425 013c 2817      		cp r18,r24
 426 013e 3907      		cpc r19,r25
 427 0140 01F0      		breq .L21
  78:matrix.c      ****             if (debouncing) {
 428               		.loc 1 78 0
 429 0142 9983      		std Y+1,r25
 430 0144 8883      		st Y,r24
  79:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 431               		.loc 1 79 0
 432 0146 8091 0000 		lds r24,debouncing
 433 014a 8823      		tst r24
 434 014c 01F0      		breq .L23
  80:matrix.c      ****             }
 435               		.loc 1 80 0
 436 014e 8091 0000 		lds r24,debug_config
 437 0152 80FF      		sbrs r24,0
 438 0154 00C0      		rjmp .L24
  80:matrix.c      ****             }
 439               		.loc 1 80 0 is_stmt 0 discriminator 1
 440 0156 80E0      		ldi r24,lo8(__c.1907)
 441 0158 90E0      		ldi r25,hi8(__c.1907)
 442 015a 0E94 0000 		call xputs
 443               	.LVL9:
 444               	.L24:
  80:matrix.c      ****             }
 445               		.loc 1 80 0 discriminator 3
 446 015e 8091 0000 		lds r24,debug_config
 447 0162 80FF      		sbrs r24,0
 448 0164 00C0      		rjmp .L25
  80:matrix.c      ****             }
 449               		.loc 1 80 0 discriminator 4
 450 0166 8091 0000 		lds r24,debouncing
 451 016a 1F92      		push __zero_reg__
 452               	.LCFI9:
 453               		.cfi_def_cfa_offset 12
 454 016c 8F93      		push r24
 455               	.LCFI10:
 456               		.cfi_def_cfa_offset 13
 457 016e FF92      		push r15
 458               	.LCFI11:
 459               		.cfi_def_cfa_offset 14
 460 0170 EF92      		push r14
 461               	.LCFI12:
 462               		.cfi_def_cfa_offset 15
 463 0172 0E94 0000 		call __xprintf
 464               	.LVL10:
 465 0176 0F90      		pop __tmp_reg__
 466 0178 0F90      		pop __tmp_reg__
 467 017a 0F90      		pop __tmp_reg__
 468 017c 0F90      		pop __tmp_reg__
 469               	.LCFI13:
 470               		.cfi_def_cfa_offset 11
 471               	.L25:
  80:matrix.c      ****             }
 472               		.loc 1 80 0 discriminator 6
 473 017e 8091 0000 		lds r24,debug_config
 474 0182 80FF      		sbrs r24,0
 475 0184 00C0      		rjmp .L23
  80:matrix.c      ****             }
 476               		.loc 1 80 0 discriminator 7
 477 0186 80E0      		ldi r24,lo8(__c.1911)
 478 0188 90E0      		ldi r25,hi8(__c.1911)
 479 018a 0E94 0000 		call xputs
 480               	.LVL11:
 481               	.L23:
  82:matrix.c      ****         }
 482               		.loc 1 82 0 is_stmt 1
 483 018e B092 0000 		sts debouncing,r11
 484               	.L21:
  84:matrix.c      ****     }
 485               		.loc 1 84 0 discriminator 2
 486 0192 0E94 0000 		call unselect_rows
 487               	.LVL12:
 488               	.LBE41:
  73:matrix.c      ****         select_row(i);
 489               		.loc 1 73 0 discriminator 2
 490 0196 D394      		inc r13
 491               	.LVL13:
 492 0198 2296      		adiw r28,2
 493 019a 94E0      		ldi r25,lo8(4)
 494 019c D912      		cpse r13,r25
 495 019e 00C0      		rjmp .L27
 496               	.LBE40:
  87:matrix.c      ****         if (--debouncing) {
 497               		.loc 1 87 0
 498 01a0 8091 0000 		lds r24,debouncing
 499 01a4 8823      		tst r24
 500 01a6 01F0      		breq .L29
  88:matrix.c      ****             _delay_ms(1);
 501               		.loc 1 88 0
 502 01a8 8150      		subi r24,lo8(-(-1))
 503 01aa 8093 0000 		sts debouncing,r24
 504 01ae 8823      		tst r24
 505 01b0 01F0      		breq .L30
 506               	.LVL14:
 507               	.LBB50:
 508               	.LBB51:
 163:/usr/lib/avr/include/util/delay.h **** 
 509               		.loc 2 163 0
 510 01b2 8FE9      		ldi r24,lo8(3999)
 511 01b4 9FE0      		ldi r25,hi8(3999)
 512 01b6 0197      	1:	sbiw r24,1
 513 01b8 01F4      		brne 1b
 514 01ba 00C0      		rjmp .
 515 01bc 0000      		nop
 516 01be 00C0      		rjmp .L29
 517               	.LVL15:
 518               	.L30:
 519               	.LBE51:
 520               	.LBE50:
 521               	.LBB52:
  92:matrix.c      ****             }
 522               		.loc 1 92 0
 523 01c0 8091 0000 		lds r24,matrix_debouncing
 524 01c4 9091 0000 		lds r25,matrix_debouncing+1
 525 01c8 9093 0000 		sts matrix+1,r25
 526 01cc 8093 0000 		sts matrix,r24
 527               	.LVL16:
 528 01d0 8091 0000 		lds r24,matrix_debouncing+2
 529 01d4 9091 0000 		lds r25,matrix_debouncing+2+1
 530 01d8 9093 0000 		sts matrix+2+1,r25
 531 01dc 8093 0000 		sts matrix+2,r24
 532               	.LVL17:
 533 01e0 8091 0000 		lds r24,matrix_debouncing+4
 534 01e4 9091 0000 		lds r25,matrix_debouncing+4+1
 535 01e8 9093 0000 		sts matrix+4+1,r25
 536 01ec 8093 0000 		sts matrix+4,r24
 537               	.LVL18:
 538 01f0 8091 0000 		lds r24,matrix_debouncing+6
 539 01f4 9091 0000 		lds r25,matrix_debouncing+6+1
 540 01f8 9093 0000 		sts matrix+6+1,r25
 541 01fc 8093 0000 		sts matrix+6,r24
 542               	.LVL19:
 543               	.L29:
 544               	.LBE52:
  98:matrix.c      **** 
 545               		.loc 1 98 0
 546 0200 81E0      		ldi r24,lo8(1)
 547               	/* epilogue start */
 548 0202 DF91      		pop r29
 549 0204 CF91      		pop r28
 550 0206 1F91      		pop r17
 551 0208 0F91      		pop r16
 552 020a FF90      		pop r15
 553 020c EF90      		pop r14
 554 020e DF90      		pop r13
 555               	.LVL20:
 556 0210 CF90      		pop r12
 557 0212 BF90      		pop r11
 558 0214 0895      		ret
 559               		.cfi_endproc
 560               	.LFE10:
 562               		.section	.text.matrix_is_modified,"ax",@progbits
 563               	.global	matrix_is_modified
 565               	matrix_is_modified:
 566               	.LFB11:
 101:matrix.c      ****     if (debouncing) return false;
 567               		.loc 1 101 0
 568               		.cfi_startproc
 569               	/* prologue: function */
 570               	/* frame size = 0 */
 571               	/* stack size = 0 */
 572               	.L__stack_usage = 0
 102:matrix.c      ****     return true;
 573               		.loc 1 102 0
 574 0000 81E0      		ldi r24,lo8(1)
 575 0002 9091 0000 		lds r25,debouncing
 576 0006 9111      		cpse r25,__zero_reg__
 577 0008 80E0      		ldi r24,0
 578               	.L54:
 104:matrix.c      **** 
 579               		.loc 1 104 0
 580 000a 0895      		ret
 581               		.cfi_endproc
 582               	.LFE11:
 584               		.section	.text.matrix_is_on,"ax",@progbits
 585               	.global	matrix_is_on
 587               	matrix_is_on:
 588               	.LFB12:
 108:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 589               		.loc 1 108 0
 590               		.cfi_startproc
 591               	.LVL21:
 592               	/* prologue: function */
 593               	/* frame size = 0 */
 594               	/* stack size = 0 */
 595               	.L__stack_usage = 0
 109:matrix.c      **** }
 596               		.loc 1 109 0
 597 0000 E82F      		mov r30,r24
 598 0002 F0E0      		ldi r31,0
 599 0004 EE0F      		lsl r30
 600 0006 FF1F      		rol r31
 601               	.LVL22:
 602 0008 E050      		subi r30,lo8(-(matrix))
 603 000a F040      		sbci r31,hi8(-(matrix))
 604 000c 21E0      		ldi r18,lo8(1)
 605 000e 30E0      		ldi r19,0
 606 0010 00C0      		rjmp 2f
 607               		1:
 608 0012 220F      		lsl r18
 609 0014 331F      		rol r19
 610               		2:
 611 0016 6A95      		dec r22
 612 0018 02F4      		brpl 1b
 613 001a 8081      		ld r24,Z
 614 001c 9181      		ldd r25,Z+1
 615 001e 2823      		and r18,r24
 616 0020 3923      		and r19,r25
 617 0022 81E0      		ldi r24,lo8(1)
 618 0024 232B      		or r18,r19
 619 0026 01F4      		brne .L59
 620 0028 80E0      		ldi r24,0
 621               	.L59:
 110:matrix.c      **** 
 622               		.loc 1 110 0
 623 002a 0895      		ret
 624               		.cfi_endproc
 625               	.LFE12:
 627               		.section	.text.matrix_get_row,"ax",@progbits
 628               	.global	matrix_get_row
 630               	matrix_get_row:
 631               	.LFB13:
 114:matrix.c      ****     return matrix[row];
 632               		.loc 1 114 0
 633               		.cfi_startproc
 634               	.LVL23:
 635               	/* prologue: function */
 636               	/* frame size = 0 */
 637               	/* stack size = 0 */
 638               	.L__stack_usage = 0
 115:matrix.c      **** }
 639               		.loc 1 115 0
 640 0000 E82F      		mov r30,r24
 641 0002 F0E0      		ldi r31,0
 642 0004 EE0F      		lsl r30
 643 0006 FF1F      		rol r31
 644               	.LVL24:
 645 0008 E050      		subi r30,lo8(-(matrix))
 646 000a F040      		sbci r31,hi8(-(matrix))
 116:matrix.c      **** 
 647               		.loc 1 116 0
 648 000c 8081      		ld r24,Z
 649 000e 9181      		ldd r25,Z+1
 650 0010 0895      		ret
 651               		.cfi_endproc
 652               	.LFE13:
 654               		.section	.text.matrix_print,"ax",@progbits
 655               	.global	matrix_print
 657               	matrix_print:
 658               	.LFB14:
 119:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 659               		.loc 1 119 0
 660               		.cfi_startproc
 661 0000 CF92      		push r12
 662               	.LCFI14:
 663               		.cfi_def_cfa_offset 3
 664               		.cfi_offset 12, -2
 665 0002 DF92      		push r13
 666               	.LCFI15:
 667               		.cfi_def_cfa_offset 4
 668               		.cfi_offset 13, -3
 669 0004 EF92      		push r14
 670               	.LCFI16:
 671               		.cfi_def_cfa_offset 5
 672               		.cfi_offset 14, -4
 673 0006 FF92      		push r15
 674               	.LCFI17:
 675               		.cfi_def_cfa_offset 6
 676               		.cfi_offset 15, -5
 677 0008 0F93      		push r16
 678               	.LCFI18:
 679               		.cfi_def_cfa_offset 7
 680               		.cfi_offset 16, -6
 681 000a 1F93      		push r17
 682               	.LCFI19:
 683               		.cfi_def_cfa_offset 8
 684               		.cfi_offset 17, -7
 685 000c CF93      		push r28
 686               	.LCFI20:
 687               		.cfi_def_cfa_offset 9
 688               		.cfi_offset 28, -8
 689 000e DF93      		push r29
 690               	.LCFI21:
 691               		.cfi_def_cfa_offset 10
 692               		.cfi_offset 29, -9
 693               	/* prologue: function */
 694               	/* frame size = 0 */
 695               	/* stack size = 8 */
 696               	.L__stack_usage = 8
 120:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 697               		.loc 1 120 0
 698 0010 80E0      		ldi r24,lo8(__c.1933)
 699 0012 90E0      		ldi r25,hi8(__c.1933)
 700 0014 0E94 0000 		call xputs
 701 0018 80E0      		ldi r24,lo8(matrix)
 702 001a E82E      		mov r14,r24
 703 001c 80E0      		ldi r24,hi8(matrix)
 704 001e F82E      		mov r15,r24
 705 0020 C0E0      		ldi r28,0
 706 0022 D0E0      		ldi r29,0
 707               	.LBB53:
 122:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 708               		.loc 1 122 0
 709 0024 90E0      		ldi r25,lo8(__c.1936)
 710 0026 C92E      		mov r12,r25
 711 0028 90E0      		ldi r25,hi8(__c.1936)
 712 002a D92E      		mov r13,r25
 123:matrix.c      ****         print("\n");
 713               		.loc 1 123 0
 714 002c 00E0      		ldi r16,lo8(__c.1940)
 715 002e 10E0      		ldi r17,hi8(__c.1940)
 716               	.L62:
 122:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 717               		.loc 1 122 0 discriminator 3
 718 0030 DF93      		push r29
 719               	.LCFI22:
 720               		.cfi_def_cfa_offset 11
 721 0032 CF93      		push r28
 722               	.LCFI23:
 723               		.cfi_def_cfa_offset 12
 724 0034 DF92      		push r13
 725               	.LCFI24:
 726               		.cfi_def_cfa_offset 13
 727 0036 CF92      		push r12
 728               	.LCFI25:
 729               		.cfi_def_cfa_offset 14
 730 0038 0E94 0000 		call __xprintf
 731 003c 80E0      		ldi r24,lo8(__c.1938)
 732 003e 90E0      		ldi r25,hi8(__c.1938)
 733 0040 0E94 0000 		call xputs
 123:matrix.c      ****         print("\n");
 734               		.loc 1 123 0 discriminator 3
 735 0044 F701      		movw r30,r14
 736 0046 8191      		ld r24,Z+
 737 0048 9191      		ld r25,Z+
 738 004a 7F01      		movw r14,r30
 739 004c 0E94 0000 		call bitrev16
 740 0050 9F93      		push r25
 741               	.LCFI26:
 742               		.cfi_def_cfa_offset 15
 743 0052 8F93      		push r24
 744               	.LCFI27:
 745               		.cfi_def_cfa_offset 16
 746 0054 1F93      		push r17
 747               	.LCFI28:
 748               		.cfi_def_cfa_offset 17
 749 0056 0F93      		push r16
 750               	.LCFI29:
 751               		.cfi_def_cfa_offset 18
 752 0058 0E94 0000 		call __xprintf
 124:matrix.c      ****     }
 753               		.loc 1 124 0 discriminator 3
 754 005c 80E0      		ldi r24,lo8(__c.1942)
 755 005e 90E0      		ldi r25,hi8(__c.1942)
 756 0060 0E94 0000 		call xputs
 757 0064 2196      		adiw r28,1
 121:matrix.c      ****         phex(row); print(": ");
 758               		.loc 1 121 0 discriminator 3
 759 0066 8DB7      		in r24,__SP_L__
 760 0068 9EB7      		in r25,__SP_H__
 761 006a 0896      		adiw r24,8
 762 006c 0FB6      		in __tmp_reg__,__SREG__
 763 006e F894      		cli
 764 0070 9EBF      		out __SP_H__,r25
 765 0072 0FBE      		out __SREG__,__tmp_reg__
 766 0074 8DBF      		out __SP_L__,r24
 767               	.LCFI30:
 768               		.cfi_def_cfa_offset 10
 769 0076 C430      		cpi r28,4
 770 0078 D105      		cpc r29,__zero_reg__
 771 007a 01F4      		brne .L62
 772               	/* epilogue start */
 773               	.LBE53:
 126:matrix.c      **** 
 774               		.loc 1 126 0
 775 007c DF91      		pop r29
 776 007e CF91      		pop r28
 777 0080 1F91      		pop r17
 778 0082 0F91      		pop r16
 779 0084 FF90      		pop r15
 780 0086 EF90      		pop r14
 781 0088 DF90      		pop r13
 782 008a CF90      		pop r12
 783 008c 0895      		ret
 784               		.cfi_endproc
 785               	.LFE14:
 787               		.section	.text.matrix_key_count,"ax",@progbits
 788               	.global	matrix_key_count
 790               	matrix_key_count:
 791               	.LFB15:
 129:matrix.c      ****     uint8_t count = 0;
 792               		.loc 1 129 0
 793               		.cfi_startproc
 794 0000 0F93      		push r16
 795               	.LCFI31:
 796               		.cfi_def_cfa_offset 3
 797               		.cfi_offset 16, -2
 798 0002 1F93      		push r17
 799               	.LCFI32:
 800               		.cfi_def_cfa_offset 4
 801               		.cfi_offset 17, -3
 802 0004 CF93      		push r28
 803               	.LCFI33:
 804               		.cfi_def_cfa_offset 5
 805               		.cfi_offset 28, -4
 806               	/* prologue: function */
 807               	/* frame size = 0 */
 808               	/* stack size = 3 */
 809               	.L__stack_usage = 3
 810               	.LVL25:
 811 0006 00E0      		ldi r16,lo8(matrix)
 812 0008 10E0      		ldi r17,hi8(matrix)
 130:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 813               		.loc 1 130 0
 814 000a C0E0      		ldi r28,0
 815               	.LVL26:
 816               	.L65:
 817               	.LBB54:
 132:matrix.c      ****     }
 818               		.loc 1 132 0 discriminator 3
 819 000c F801      		movw r30,r16
 820 000e 8191      		ld r24,Z+
 821 0010 9191      		ld r25,Z+
 822 0012 8F01      		movw r16,r30
 823 0014 0E94 0000 		call bitpop16
 824               	.LVL27:
 825 0018 C80F      		add r28,r24
 826               	.LVL28:
 131:matrix.c      ****         count += bitpop16(matrix[i]);
 827               		.loc 1 131 0 discriminator 3
 828 001a F0E0      		ldi r31,hi8(matrix+8)
 829 001c 0030      		cpi r16,lo8(matrix+8)
 830 001e 1F07      		cpc r17,r31
 831 0020 01F4      		brne .L65
 832               	.LBE54:
 135:matrix.c      **** 
 833               		.loc 1 135 0
 834 0022 8C2F      		mov r24,r28
 835               	/* epilogue start */
 836 0024 CF91      		pop r28
 837               	.LVL29:
 838 0026 1F91      		pop r17
 839 0028 0F91      		pop r16
 840 002a 0895      		ret
 841               		.cfi_endproc
 842               	.LFE15:
 844               		.section	.progmem.data,"a",@progbits
 847               	__c.1942:
 848 0000 0A00      		.string	"\n"
 851               	__c.1940:
 852 0002 2530 3136 		.string	"%016b"
 852      6200 
 855               	__c.1938:
 856 0008 3A20 00   		.string	": "
 859               	__c.1936:
 860 000b 2530 3258 		.string	"%02X"
 860      00
 863               	__c.1933:
 864 0010 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 864      2030 3132 
 864      3334 3536 
 864      3738 3941 
 864      4243 4445 
 867               	__c.1911:
 868 0027 0A00      		.string	"\n"
 871               	__c.1909:
 872 0029 2530 3258 		.string	"%02X"
 872      00
 875               	__c.1907:
 876 002e 626F 756E 		.string	"bounce!: "
 876      6365 213A 
 876      2000 
 877               	.global	rows
 878               		.data
 881               	rows:
 882 0000 0000      		.word	0
 883 0002 0100      		.word	1
 884 0004 0300      		.word	3
 885 0006 0200      		.word	2
 886               		.local	matrix_debouncing
 887               		.comm	matrix_debouncing,8,1
 888               		.local	matrix
 889               		.comm	matrix,8,1
 892               	debouncing:
 893 0008 05        		.byte	5
 894               		.comm	debug_config,1,1
 895               		.text
 896               	.Letext0:
 897               		.file 3 "/usr/lib/avr/include/stdint.h"
 898               		.file 4 "../../common/debug_config.h"
 899               		.file 5 "../../common/matrix.h"
 900               		.file 6 "../../common/xprintf.h"
 901               		.file 7 "../../common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccXGRZlz.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccXGRZlz.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccXGRZlz.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccXGRZlz.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccXGRZlz.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccXGRZlz.s:12     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccXGRZlz.s:36     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccXGRZlz.s:53     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccXGRZlz.s:70     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccXGRZlz.s:887    .bss:0000000000000008 matrix
                             .bss:0000000000000000 matrix_debouncing
     /tmp/ccXGRZlz.s:150    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccXGRZlz.s:871    .progmem.data:0000000000000029 __c.1909
     /tmp/ccXGRZlz.s:892    .data:0000000000000008 debouncing
                            *COM*:0000000000000001 debug_config
     /tmp/ccXGRZlz.s:875    .progmem.data:000000000000002e __c.1907
     /tmp/ccXGRZlz.s:867    .progmem.data:0000000000000027 __c.1911
     /tmp/ccXGRZlz.s:565    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccXGRZlz.s:587    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccXGRZlz.s:630    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccXGRZlz.s:657    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccXGRZlz.s:863    .progmem.data:0000000000000010 __c.1933
     /tmp/ccXGRZlz.s:859    .progmem.data:000000000000000b __c.1936
     /tmp/ccXGRZlz.s:851    .progmem.data:0000000000000002 __c.1940
     /tmp/ccXGRZlz.s:855    .progmem.data:0000000000000008 __c.1938
     /tmp/ccXGRZlz.s:847    .progmem.data:0000000000000000 __c.1942
     /tmp/ccXGRZlz.s:790    .text.matrix_key_count:0000000000000000 matrix_key_count
     /tmp/ccXGRZlz.s:881    .data:0000000000000000 rows

UNDEFINED SYMBOLS
xputs
__xprintf
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
