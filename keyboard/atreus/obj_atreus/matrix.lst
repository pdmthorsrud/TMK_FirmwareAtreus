   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB18:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #   define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // initialize row and col
  61:matrix.c      ****     unselect_rows();
  62:matrix.c      ****     init_cols();
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize matrix state: all keys off
  65:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  66:matrix.c      ****         matrix[i] = 0;
  67:matrix.c      ****         matrix_debouncing[i] = 0;
  68:matrix.c      ****     }
  69:matrix.c      **** }
  70:matrix.c      **** 
  71:matrix.c      **** uint8_t matrix_scan(void)
  72:matrix.c      **** {
  73:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  74:matrix.c      ****         select_row(i);
  75:matrix.c      ****         _delay_us(50);  // without this wait read unstable value.
  76:matrix.c      ****         matrix_row_t cols = read_cols();
  77:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  78:matrix.c      ****             matrix_debouncing[i] = cols;
  79:matrix.c      ****             if (debouncing) {
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  81:matrix.c      ****             }
  82:matrix.c      ****             debouncing = DEBOUNCE;
  83:matrix.c      ****         }
  84:matrix.c      ****         unselect_rows();
  85:matrix.c      ****     }
  86:matrix.c      **** 
  87:matrix.c      ****     if (debouncing) {
  88:matrix.c      ****         if (--debouncing) {
  89:matrix.c      ****             _delay_ms(1);
  90:matrix.c      ****         } else {
  91:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  92:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  93:matrix.c      ****             }
  94:matrix.c      ****         }
  95:matrix.c      ****     }
  96:matrix.c      **** 
  97:matrix.c      ****     return 1;
  98:matrix.c      **** }
  99:matrix.c      **** 
 100:matrix.c      **** bool matrix_is_modified(void)
 101:matrix.c      **** {
 102:matrix.c      ****     if (debouncing) return false;
 103:matrix.c      ****     return true;
 104:matrix.c      **** }
 105:matrix.c      **** 
 106:matrix.c      **** inline
 107:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 108:matrix.c      **** {
 109:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 110:matrix.c      **** }
 111:matrix.c      **** 
 112:matrix.c      **** inline
 113:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 114:matrix.c      **** {
 115:matrix.c      ****     return matrix[row];
 116:matrix.c      **** }
 117:matrix.c      **** 
 118:matrix.c      **** void matrix_print(void)
 119:matrix.c      **** {
 120:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 121:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 122:matrix.c      ****         phex(row); print(": ");
 123:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 124:matrix.c      ****         print("\n");
 125:matrix.c      ****     }
 126:matrix.c      **** }
 127:matrix.c      **** 
 128:matrix.c      **** uint8_t matrix_key_count(void)
 129:matrix.c      **** {
 130:matrix.c      ****     uint8_t count = 0;
 131:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 132:matrix.c      ****         count += bitpop16(matrix[i]);
 133:matrix.c      ****     }
 134:matrix.c      ****     return count;
 135:matrix.c      **** }
 136:matrix.c      **** 
 137:matrix.c      **** /* Column pin configuration
 138:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   10
 139:matrix.c      ****  * pin: B7  D6  F7  F6  B6  D4  E6  B4  B5  C6  D7
 140:matrix.c      ****  */
 141:matrix.c      **** static void  init_cols(void)
 142:matrix.c      **** {
 143:matrix.c      ****   // Input with pull-up(DDR:0, PORT:1)
 144:matrix.c      ****   DDRF  &= ~(1<<4 | 1<<5 | 1<<6);
 145:matrix.c      ****   PORTF |=  (1<<4 | 1<<5 | 1<<6);
 146:matrix.c      ****   DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 147:matrix.c      ****   PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 148:matrix.c      **** }
 149:matrix.c      **** 
 150:matrix.c      **** static matrix_row_t read_cols(void)
 151:matrix.c      **** {
 152:matrix.c      **** #ifdef TEENSY
 153:matrix.c      ****     return (PINF&(1<<6) ? 0 : (1<<0)) |
 154:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 155:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 156:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 157:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 158:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 159:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 160:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 161:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 162:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 163:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<10)) ;
 164:matrix.c      **** #else
 165:matrix.c      ****     return (PINF&(1<<6) ? 0 : (1<<0)) |
 166:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 167:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 168:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 169:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 170:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 171:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 172:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 173:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 174:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 175:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<10)) ;
 176:matrix.c      **** #endif
 177:matrix.c      **** }
 178:matrix.c      **** 
 179:matrix.c      **** /* Row pin configuration
 180:matrix.c      ****  * row: 0   1   2   3
 181:matrix.c      ****  * pin: D0  D1  D3  D2    (a-star micro)
 182:matrix.c      ****  * pin: D0  D1  D2  D3    (teensy2)
 183:matrix.c      ****  */
 184:matrix.c      **** static void unselect_rows(void)
 185:matrix.c      **** {
  15               		.loc 1 185 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 186:matrix.c      ****   // Hi-Z(DDR:0, PORT:0) to unselect
 187:matrix.c      ****   DDRD  &= ~0b00001111;
  21               		.loc 1 187 0
  22 0000 8AB1      		in r24,0xa
  23 0002 807F      		andi r24,lo8(-16)
  24 0004 8AB9      		out 0xa,r24
 188:matrix.c      ****   PORTD &= ~0b00001111;
  25               		.loc 1 188 0
  26 0006 8BB1      		in r24,0xb
  27 0008 807F      		andi r24,lo8(-16)
  28 000a 8BB9      		out 0xb,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE18:
  33               		.section	.text.matrix_rows,"ax",@progbits
  34               	.global	matrix_rows
  36               	matrix_rows:
  37               	.LFB7:
  48:matrix.c      **** {
  38               		.loc 1 48 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
  50:matrix.c      **** }
  44               		.loc 1 50 0
  45 0000 84E0      		ldi r24,lo8(4)
  46 0002 0895      		ret
  47               		.cfi_endproc
  48               	.LFE7:
  50               		.section	.text.matrix_cols,"ax",@progbits
  51               	.global	matrix_cols
  53               	matrix_cols:
  54               	.LFB8:
  54:matrix.c      **** {
  55               		.loc 1 54 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  56:matrix.c      **** }
  61               		.loc 1 56 0
  62 0000 8BE0      		ldi r24,lo8(11)
  63 0002 0895      		ret
  64               		.cfi_endproc
  65               	.LFE8:
  67               		.section	.text.matrix_init,"ax",@progbits
  68               	.global	matrix_init
  70               	matrix_init:
  71               	.LFB9:
  59:matrix.c      **** {
  72               		.loc 1 59 0
  73               		.cfi_startproc
  74               	/* prologue: function */
  75               	/* frame size = 0 */
  76               	/* stack size = 0 */
  77               	.L__stack_usage = 0
  61:matrix.c      ****     unselect_rows();
  78               		.loc 1 61 0
  79 0000 0E94 0000 		call unselect_rows
  80               	.LVL0:
  81               	.LBB23:
  82               	.LBB24:
 144:matrix.c      ****   DDRF  &= ~(1<<4 | 1<<5 | 1<<6);
  83               		.loc 1 144 0
  84 0004 80B3      		in r24,0x10
  85 0006 8F78      		andi r24,lo8(-113)
  86 0008 80BB      		out 0x10,r24
 145:matrix.c      ****   PORTF |=  (1<<4 | 1<<5 | 1<<6);
  87               		.loc 1 145 0
  88 000a 81B3      		in r24,0x11
  89 000c 8067      		ori r24,lo8(112)
  90 000e 81BB      		out 0x11,r24
 146:matrix.c      ****   DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
  91               		.loc 1 146 0
  92 0010 84B1      		in r24,0x4
  93 0012 14B8      		out 0x4,__zero_reg__
 147:matrix.c      ****   PORTB |=  (1<<0 | 1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
  94               		.loc 1 147 0
  95 0014 85B1      		in r24,0x5
  96 0016 8FEF      		ldi r24,lo8(-1)
  97 0018 85B9      		out 0x5,r24
  98               	.LVL1:
  99               	.LBE24:
 100               	.LBE23:
 101               	.LBB25:
  66:matrix.c      ****         matrix[i] = 0;
 102               		.loc 1 66 0
 103 001a 1092 0000 		sts matrix+1,__zero_reg__
 104 001e 1092 0000 		sts matrix,__zero_reg__
  67:matrix.c      ****         matrix_debouncing[i] = 0;
 105               		.loc 1 67 0
 106 0022 1092 0000 		sts matrix_debouncing+1,__zero_reg__
 107 0026 1092 0000 		sts matrix_debouncing,__zero_reg__
 108               	.LVL2:
  66:matrix.c      ****         matrix[i] = 0;
 109               		.loc 1 66 0
 110 002a 1092 0000 		sts matrix+2+1,__zero_reg__
 111 002e 1092 0000 		sts matrix+2,__zero_reg__
  67:matrix.c      ****         matrix_debouncing[i] = 0;
 112               		.loc 1 67 0
 113 0032 1092 0000 		sts matrix_debouncing+2+1,__zero_reg__
 114 0036 1092 0000 		sts matrix_debouncing+2,__zero_reg__
 115               	.LVL3:
  66:matrix.c      ****         matrix[i] = 0;
 116               		.loc 1 66 0
 117 003a 1092 0000 		sts matrix+4+1,__zero_reg__
 118 003e 1092 0000 		sts matrix+4,__zero_reg__
  67:matrix.c      ****         matrix_debouncing[i] = 0;
 119               		.loc 1 67 0
 120 0042 1092 0000 		sts matrix_debouncing+4+1,__zero_reg__
 121 0046 1092 0000 		sts matrix_debouncing+4,__zero_reg__
 122               	.LVL4:
  66:matrix.c      ****         matrix[i] = 0;
 123               		.loc 1 66 0
 124 004a 1092 0000 		sts matrix+6+1,__zero_reg__
 125 004e 1092 0000 		sts matrix+6,__zero_reg__
  67:matrix.c      ****         matrix_debouncing[i] = 0;
 126               		.loc 1 67 0
 127 0052 1092 0000 		sts matrix_debouncing+6+1,__zero_reg__
 128 0056 1092 0000 		sts matrix_debouncing+6,__zero_reg__
 129               	.LVL5:
 130 005a 0895      		ret
 131               	.LBE25:
 132               		.cfi_endproc
 133               	.LFE9:
 135               		.section	.text.matrix_scan,"ax",@progbits
 136               	.global	matrix_scan
 138               	matrix_scan:
 139               	.LFB10:
  72:matrix.c      **** {
 140               		.loc 1 72 0
 141               		.cfi_startproc
 142 0000 BF92      		push r11
 143               	.LCFI0:
 144               		.cfi_def_cfa_offset 3
 145               		.cfi_offset 11, -2
 146 0002 CF92      		push r12
 147               	.LCFI1:
 148               		.cfi_def_cfa_offset 4
 149               		.cfi_offset 12, -3
 150 0004 DF92      		push r13
 151               	.LCFI2:
 152               		.cfi_def_cfa_offset 5
 153               		.cfi_offset 13, -4
 154 0006 EF92      		push r14
 155               	.LCFI3:
 156               		.cfi_def_cfa_offset 6
 157               		.cfi_offset 14, -5
 158 0008 FF92      		push r15
 159               	.LCFI4:
 160               		.cfi_def_cfa_offset 7
 161               		.cfi_offset 15, -6
 162 000a 0F93      		push r16
 163               	.LCFI5:
 164               		.cfi_def_cfa_offset 8
 165               		.cfi_offset 16, -7
 166 000c 1F93      		push r17
 167               	.LCFI6:
 168               		.cfi_def_cfa_offset 9
 169               		.cfi_offset 17, -8
 170 000e CF93      		push r28
 171               	.LCFI7:
 172               		.cfi_def_cfa_offset 10
 173               		.cfi_offset 28, -9
 174 0010 DF93      		push r29
 175               	.LCFI8:
 176               		.cfi_def_cfa_offset 11
 177               		.cfi_offset 29, -10
 178               	/* prologue: function */
 179               	/* frame size = 0 */
 180               	/* stack size = 9 */
 181               	.L__stack_usage = 9
 182               	.LVL6:
 183 0012 C0E0      		ldi r28,lo8(matrix_debouncing)
 184 0014 D0E0      		ldi r29,hi8(matrix_debouncing)
 185               	.LBB40:
  73:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 186               		.loc 1 73 0
 187 0016 D12C      		mov r13,__zero_reg__
 188               	.LBB41:
 189               	.LBB42:
 190               	.LBB43:
 165:matrix.c      ****     return (PINF&(1<<6) ? 0 : (1<<0)) |
 191               		.loc 1 165 0
 192 0018 CC24      		clr r12
 193 001a C394      		inc r12
 194               	.LBE43:
 195               	.LBE42:
  82:matrix.c      ****             debouncing = DEBOUNCE;
 196               		.loc 1 82 0
 197 001c 65E0      		ldi r22,lo8(5)
 198 001e B62E      		mov r11,r22
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 199               		.loc 1 80 0
 200 0020 70E0      		ldi r23,lo8(__c.1891)
 201 0022 E72E      		mov r14,r23
 202 0024 70E0      		ldi r23,hi8(__c.1891)
 203 0026 F72E      		mov r15,r23
 204               	.LVL7:
 205               	.L28:
 206               	.LBB45:
 207               	.LBB46:
 189:matrix.c      **** }
 190:matrix.c      **** 
 191:matrix.c      **** #define ROW_COUNT 4
 192:matrix.c      **** #ifdef TEENSY
 193:matrix.c      **** int rows[ROW_COUNT] = {0, 1, 2, 3};
 194:matrix.c      **** #else
 195:matrix.c      **** int rows[ROW_COUNT] = {0, 1, 3, 2};
 196:matrix.c      **** #endif
 197:matrix.c      **** 
 198:matrix.c      **** static void select_row(uint8_t row)
 199:matrix.c      **** {
 200:matrix.c      ****   // Output low(DDR:1, PORT:0) to select
 201:matrix.c      ****   switch (row) {
 208               		.loc 1 201 0
 209 0028 82E0      		ldi r24,lo8(2)
 210 002a D816      		cp r13,r24
 211 002c 01F0      		breq .L7
 212 002e 93E0      		ldi r25,lo8(3)
 213 0030 D916      		cp r13,r25
 214 0032 01F0      		breq .L8
 215 0034 81E0      		ldi r24,lo8(1)
 216 0036 D816      		cp r13,r24
 217 0038 01F0      		breq .L9
 202:matrix.c      ****       case 0:
 203:matrix.c      ****           DDRD  |= (1<<0);
 218               		.loc 1 203 0
 219 003a 509A      		sbi 0xa,0
 204:matrix.c      ****           PORTD &= ~(1<<0);
 220               		.loc 1 204 0
 221 003c 5898      		cbi 0xb,0
 222 003e 00C0      		rjmp .L10
 223               	.L9:
 205:matrix.c      ****           break;
 206:matrix.c      ****       case 1:
 207:matrix.c      ****           DDRD  |= (1<<1);
 224               		.loc 1 207 0
 225 0040 519A      		sbi 0xa,1
 208:matrix.c      ****           PORTD &= ~(1<<1);
 226               		.loc 1 208 0
 227 0042 5998      		cbi 0xb,1
 228 0044 00C0      		rjmp .L10
 229               	.L7:
 209:matrix.c      ****           break;
 210:matrix.c      ****       case 2:
 211:matrix.c      ****           DDRD  |= (1<<2);
 230               		.loc 1 211 0
 231 0046 529A      		sbi 0xa,2
 212:matrix.c      ****           PORTD &= ~(1<<2);
 232               		.loc 1 212 0
 233 0048 5A98      		cbi 0xb,2
 234 004a 00C0      		rjmp .L10
 235               	.L8:
 213:matrix.c      ****           break;
 214:matrix.c      ****       case 3:
 215:matrix.c      ****           DDRD  |= (1<<3);
 236               		.loc 1 215 0
 237 004c 539A      		sbi 0xa,3
 216:matrix.c      ****           PORTD &= ~(1<<3);
 238               		.loc 1 216 0
 239 004e 5B98      		cbi 0xb,3
 240               	.L10:
 241               	.LVL8:
 242               	.LBE46:
 243               	.LBE45:
 244               	.LBB47:
 245               	.LBB48:
 246               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 247               		.loc 2 246 0
 248 0050 87EC      		ldi r24,lo8(199)
 249 0052 90E0      		ldi r25,hi8(199)
 250 0054 0197      		1: sbiw r24,1
 251 0056 01F4      		brne 1b
 252 0058 00C0      		rjmp .
 253 005a 0000      		nop
 254               	.LBE48:
 255               	.LBE47:
 256               	.LBB49:
 257               	.LBB44:
 165:matrix.c      ****     return (PINF&(1<<6) ? 0 : (1<<0)) |
 258               		.loc 1 165 0
 259 005c 8FB1      		in r24,0xf
 260 005e 8295      		swap r24
 261 0060 8695      		lsr r24
 262 0062 8695      		lsr r24
 263 0064 8370      		andi r24,lo8(3)
 264 0066 8C25      		eor r24,r12
 265 0068 082F      		mov r16,r24
 266 006a 0170      		andi r16,1
 267 006c 10E0      		ldi r17,0
 166:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 268               		.loc 1 166 0
 269 006e 7D9B      		sbis 0xf,5
 270 0070 00C0      		rjmp .L33
 271 0072 20E0      		ldi r18,0
 272 0074 30E0      		ldi r19,0
 273 0076 00C0      		rjmp .L11
 274               	.L33:
 275 0078 22E0      		ldi r18,lo8(2)
 276 007a 30E0      		ldi r19,0
 277               	.L11:
 165:matrix.c      ****     return (PINF&(1<<6) ? 0 : (1<<0)) |
 278               		.loc 1 165 0
 279 007c 202B      		or r18,r16
 280 007e 312B      		or r19,r17
 167:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 281               		.loc 1 167 0
 282 0080 7C9B      		sbis 0xf,4
 283 0082 00C0      		rjmp .L34
 284 0084 80E0      		ldi r24,0
 285 0086 90E0      		ldi r25,0
 286 0088 00C0      		rjmp .L12
 287               	.L34:
 288 008a 84E0      		ldi r24,lo8(4)
 289 008c 90E0      		ldi r25,0
 290               	.L12:
 166:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<1)) |
 291               		.loc 1 166 0
 292 008e 282B      		or r18,r24
 293 0090 392B      		or r19,r25
 168:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 294               		.loc 1 168 0
 295 0092 83B1      		in r24,0x3
 296 0094 9927      		clr r25
 297 0096 87FD      		sbrc r24,7
 298 0098 9095      		com r25
 299 009a 8095      		com r24
 300 009c 9095      		com r25
 301 009e 8827      		clr r24
 302 00a0 990F      		lsl r25
 303 00a2 881F      		rol r24
 304 00a4 9927      		clr r25
 305 00a6 53E0      		ldi r21,3
 306               		1:
 307 00a8 880F      		lsl r24
 308 00aa 991F      		rol r25
 309 00ac 5A95      		dec r21
 310 00ae 01F4      		brne 1b
 167:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<2)) |
 311               		.loc 1 167 0
 312 00b0 282B      		or r18,r24
 313 00b2 392B      		or r19,r25
 169:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 314               		.loc 1 169 0
 315 00b4 1E9B      		sbis 0x3,6
 316 00b6 00C0      		rjmp .L36
 317 00b8 40E0      		ldi r20,0
 318 00ba 50E0      		ldi r21,0
 319 00bc 00C0      		rjmp .L14
 320               	.L36:
 321 00be 40E1      		ldi r20,lo8(16)
 322 00c0 50E0      		ldi r21,0
 323               	.L14:
 168:matrix.c      ****            (PINB&(1<<7) ? 0 : (1<<3)) |
 324               		.loc 1 168 0
 325 00c2 242B      		or r18,r20
 326 00c4 352B      		or r19,r21
 170:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 327               		.loc 1 170 0
 328 00c6 1D9B      		sbis 0x3,5
 329 00c8 00C0      		rjmp .L37
 330 00ca 40E0      		ldi r20,0
 331 00cc 50E0      		ldi r21,0
 332 00ce 00C0      		rjmp .L15
 333               	.L37:
 334 00d0 40E2      		ldi r20,lo8(32)
 335 00d2 50E0      		ldi r21,0
 336               	.L15:
 169:matrix.c      ****            (PINB&(1<<6) ? 0 : (1<<4)) |
 337               		.loc 1 169 0
 338 00d4 422B      		or r20,r18
 339 00d6 532B      		or r21,r19
 171:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 340               		.loc 1 171 0
 341 00d8 1C9B      		sbis 0x3,4
 342 00da 00C0      		rjmp .L38
 343 00dc 80E0      		ldi r24,0
 344 00de 90E0      		ldi r25,0
 345 00e0 00C0      		rjmp .L16
 346               	.L38:
 347 00e2 80E4      		ldi r24,lo8(64)
 348 00e4 90E0      		ldi r25,0
 349               	.L16:
 170:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<5)) |
 350               		.loc 1 170 0
 351 00e6 842B      		or r24,r20
 352 00e8 952B      		or r25,r21
 172:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 353               		.loc 1 172 0
 354 00ea 1B9B      		sbis 0x3,3
 355 00ec 00C0      		rjmp .L39
 356 00ee E0E0      		ldi r30,0
 357 00f0 F0E0      		ldi r31,0
 358 00f2 00C0      		rjmp .L17
 359               	.L39:
 360 00f4 E0E8      		ldi r30,lo8(-128)
 361 00f6 F0E0      		ldi r31,0
 362               	.L17:
 171:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<6)) |
 363               		.loc 1 171 0
 364 00f8 8E2B      		or r24,r30
 365 00fa 9F2B      		or r25,r31
 173:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 366               		.loc 1 173 0
 367 00fc 1A9B      		sbis 0x3,2
 368 00fe 00C0      		rjmp .L40
 369 0100 60E0      		ldi r22,0
 370 0102 70E0      		ldi r23,0
 371 0104 00C0      		rjmp .L18
 372               	.L40:
 373 0106 60E0      		ldi r22,0
 374 0108 71E0      		ldi r23,lo8(1)
 375               	.L18:
 172:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<7)) |
 376               		.loc 1 172 0
 377 010a 862B      		or r24,r22
 378 010c 972B      		or r25,r23
 174:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 379               		.loc 1 174 0
 380 010e 199B      		sbis 0x3,1
 381 0110 00C0      		rjmp .L41
 382 0112 40E0      		ldi r20,0
 383 0114 50E0      		ldi r21,0
 384 0116 00C0      		rjmp .L19
 385               	.L41:
 386 0118 40E0      		ldi r20,0
 387 011a 52E0      		ldi r21,lo8(2)
 388               	.L19:
 173:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<8)) |
 389               		.loc 1 173 0
 390 011c 842B      		or r24,r20
 391 011e 952B      		or r25,r21
 175:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<10)) ;
 392               		.loc 1 175 0
 393 0120 189B      		sbis 0x3,0
 394 0122 00C0      		rjmp .L42
 395 0124 40E0      		ldi r20,0
 396 0126 50E0      		ldi r21,0
 397 0128 00C0      		rjmp .L20
 398               	.L42:
 399 012a 40E0      		ldi r20,0
 400 012c 54E0      		ldi r21,lo8(4)
 401               	.L20:
 174:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<9)) |
 402               		.loc 1 174 0
 403 012e 842B      		or r24,r20
 404 0130 952B      		or r25,r21
 405               	.LBE44:
 406               	.LBE49:
  77:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 407               		.loc 1 77 0
 408 0132 2881      		ld r18,Y
 409 0134 3981      		ldd r19,Y+1
 410 0136 2817      		cp r18,r24
 411 0138 3907      		cpc r19,r25
 412 013a 01F0      		breq .L21
  78:matrix.c      ****             matrix_debouncing[i] = cols;
 413               		.loc 1 78 0
 414 013c 9983      		std Y+1,r25
 415 013e 8883      		st Y,r24
  79:matrix.c      ****             if (debouncing) {
 416               		.loc 1 79 0
 417 0140 8091 0000 		lds r24,debouncing
 418 0144 8823      		tst r24
 419 0146 01F0      		breq .L23
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 420               		.loc 1 80 0
 421 0148 8091 0000 		lds r24,debug_config
 422 014c 80FF      		sbrs r24,0
 423 014e 00C0      		rjmp .L24
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 424               		.loc 1 80 0 is_stmt 0 discriminator 1
 425 0150 80E0      		ldi r24,lo8(__c.1889)
 426 0152 90E0      		ldi r25,hi8(__c.1889)
 427 0154 0E94 0000 		call xputs
 428               	.LVL9:
 429               	.L24:
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 430               		.loc 1 80 0 discriminator 2
 431 0158 8091 0000 		lds r24,debug_config
 432 015c 80FF      		sbrs r24,0
 433 015e 00C0      		rjmp .L25
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 434               		.loc 1 80 0 discriminator 1
 435 0160 8091 0000 		lds r24,debouncing
 436 0164 1F92      		push __zero_reg__
 437               	.LCFI9:
 438               		.cfi_def_cfa_offset 12
 439 0166 8F93      		push r24
 440               	.LCFI10:
 441               		.cfi_def_cfa_offset 13
 442 0168 FF92      		push r15
 443               	.LCFI11:
 444               		.cfi_def_cfa_offset 14
 445 016a EF92      		push r14
 446               	.LCFI12:
 447               		.cfi_def_cfa_offset 15
 448 016c 0E94 0000 		call __xprintf
 449               	.LVL10:
 450 0170 0F90      		pop __tmp_reg__
 451 0172 0F90      		pop __tmp_reg__
 452 0174 0F90      		pop __tmp_reg__
 453 0176 0F90      		pop __tmp_reg__
 454               	.LCFI13:
 455               		.cfi_def_cfa_offset 11
 456               	.L25:
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 457               		.loc 1 80 0 discriminator 2
 458 0178 8091 0000 		lds r24,debug_config
 459 017c 80FF      		sbrs r24,0
 460 017e 00C0      		rjmp .L23
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 461               		.loc 1 80 0 discriminator 1
 462 0180 80E0      		ldi r24,lo8(__c.1893)
 463 0182 90E0      		ldi r25,hi8(__c.1893)
 464 0184 0E94 0000 		call xputs
 465               	.LVL11:
 466               	.L23:
  82:matrix.c      ****             debouncing = DEBOUNCE;
 467               		.loc 1 82 0 is_stmt 1
 468 0188 B092 0000 		sts debouncing,r11
 469               	.L21:
  84:matrix.c      ****         unselect_rows();
 470               		.loc 1 84 0
 471 018c 0E94 0000 		call unselect_rows
 472               	.LVL12:
 473               	.LBE41:
  73:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 474               		.loc 1 73 0
 475 0190 D394      		inc r13
 476               	.LVL13:
 477 0192 2296      		adiw r28,2
 478 0194 94E0      		ldi r25,lo8(4)
 479 0196 D912      		cpse r13,r25
 480 0198 00C0      		rjmp .L28
 481               	.LBE40:
  87:matrix.c      ****     if (debouncing) {
 482               		.loc 1 87 0
 483 019a 8091 0000 		lds r24,debouncing
 484 019e 8823      		tst r24
 485 01a0 01F0      		breq .L30
  88:matrix.c      ****         if (--debouncing) {
 486               		.loc 1 88 0
 487 01a2 8150      		subi r24,lo8(-(-1))
 488 01a4 8093 0000 		sts debouncing,r24
 489 01a8 8823      		tst r24
 490 01aa 01F0      		breq .L31
 491               	.LVL14:
 492               	.LBB50:
 493               	.LBB51:
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 494               		.loc 2 164 0
 495 01ac 8FE9      		ldi r24,lo8(3999)
 496 01ae 9FE0      		ldi r25,hi8(3999)
 497 01b0 0197      		1: sbiw r24,1
 498 01b2 01F4      		brne 1b
 499 01b4 00C0      		rjmp .
 500 01b6 0000      		nop
 501 01b8 00C0      		rjmp .L30
 502               	.LVL15:
 503               	.L31:
 504               	.LBE51:
 505               	.LBE50:
 506               	.LBB52:
  92:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 507               		.loc 1 92 0
 508 01ba 8091 0000 		lds r24,matrix_debouncing
 509 01be 9091 0000 		lds r25,matrix_debouncing+1
 510 01c2 9093 0000 		sts matrix+1,r25
 511 01c6 8093 0000 		sts matrix,r24
 512               	.LVL16:
 513 01ca 8091 0000 		lds r24,matrix_debouncing+2
 514 01ce 9091 0000 		lds r25,matrix_debouncing+2+1
 515 01d2 9093 0000 		sts matrix+2+1,r25
 516 01d6 8093 0000 		sts matrix+2,r24
 517               	.LVL17:
 518 01da 8091 0000 		lds r24,matrix_debouncing+4
 519 01de 9091 0000 		lds r25,matrix_debouncing+4+1
 520 01e2 9093 0000 		sts matrix+4+1,r25
 521 01e6 8093 0000 		sts matrix+4,r24
 522               	.LVL18:
 523 01ea 8091 0000 		lds r24,matrix_debouncing+6
 524 01ee 9091 0000 		lds r25,matrix_debouncing+6+1
 525 01f2 9093 0000 		sts matrix+6+1,r25
 526 01f6 8093 0000 		sts matrix+6,r24
 527               	.LVL19:
 528               	.L30:
 529               	.LBE52:
  98:matrix.c      **** }
 530               		.loc 1 98 0
 531 01fa 81E0      		ldi r24,lo8(1)
 532               	/* epilogue start */
 533 01fc DF91      		pop r29
 534 01fe CF91      		pop r28
 535 0200 1F91      		pop r17
 536 0202 0F91      		pop r16
 537 0204 FF90      		pop r15
 538 0206 EF90      		pop r14
 539 0208 DF90      		pop r13
 540               	.LVL20:
 541 020a CF90      		pop r12
 542 020c BF90      		pop r11
 543 020e 0895      		ret
 544               		.cfi_endproc
 545               	.LFE10:
 547               		.section	.text.matrix_is_modified,"ax",@progbits
 548               	.global	matrix_is_modified
 550               	matrix_is_modified:
 551               	.LFB11:
 101:matrix.c      **** {
 552               		.loc 1 101 0
 553               		.cfi_startproc
 554               	/* prologue: function */
 555               	/* frame size = 0 */
 556               	/* stack size = 0 */
 557               	.L__stack_usage = 0
 102:matrix.c      ****     if (debouncing) return false;
 558               		.loc 1 102 0
 559 0000 81E0      		ldi r24,lo8(1)
 560 0002 9091 0000 		lds r25,debouncing
 561 0006 9111      		cpse r25,__zero_reg__
 562 0008 80E0      		ldi r24,0
 563               	.L54:
 104:matrix.c      **** }
 564               		.loc 1 104 0
 565 000a 0895      		ret
 566               		.cfi_endproc
 567               	.LFE11:
 569               		.section	.text.matrix_is_on,"ax",@progbits
 570               	.global	matrix_is_on
 572               	matrix_is_on:
 573               	.LFB12:
 108:matrix.c      **** {
 574               		.loc 1 108 0
 575               		.cfi_startproc
 576               	.LVL21:
 577               	/* prologue: function */
 578               	/* frame size = 0 */
 579               	/* stack size = 0 */
 580               	.L__stack_usage = 0
 109:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 581               		.loc 1 109 0
 582 0000 E82F      		mov r30,r24
 583 0002 F0E0      		ldi r31,0
 584 0004 EE0F      		lsl r30
 585 0006 FF1F      		rol r31
 586 0008 E050      		subi r30,lo8(-(matrix))
 587 000a F040      		sbci r31,hi8(-(matrix))
 588 000c 21E0      		ldi r18,lo8(1)
 589 000e 30E0      		ldi r19,0
 590 0010 00C0      		rjmp 2f
 591               		1:
 592 0012 220F      		lsl r18
 593 0014 331F      		rol r19
 594               		2:
 595 0016 6A95      		dec r22
 596 0018 02F4      		brpl 1b
 597 001a 8081      		ld r24,Z
 598 001c 9181      		ldd r25,Z+1
 599               	.LVL22:
 600 001e 2823      		and r18,r24
 601 0020 3923      		and r19,r25
 602 0022 81E0      		ldi r24,lo8(1)
 603 0024 232B      		or r18,r19
 604 0026 01F4      		brne .L59
 605 0028 80E0      		ldi r24,0
 606               	.L59:
 110:matrix.c      **** }
 607               		.loc 1 110 0
 608 002a 0895      		ret
 609               		.cfi_endproc
 610               	.LFE12:
 612               		.section	.text.matrix_get_row,"ax",@progbits
 613               	.global	matrix_get_row
 615               	matrix_get_row:
 616               	.LFB13:
 114:matrix.c      **** {
 617               		.loc 1 114 0
 618               		.cfi_startproc
 619               	.LVL23:
 620               	/* prologue: function */
 621               	/* frame size = 0 */
 622               	/* stack size = 0 */
 623               	.L__stack_usage = 0
 115:matrix.c      ****     return matrix[row];
 624               		.loc 1 115 0
 625 0000 E82F      		mov r30,r24
 626 0002 F0E0      		ldi r31,0
 627 0004 EE0F      		lsl r30
 628 0006 FF1F      		rol r31
 629 0008 E050      		subi r30,lo8(-(matrix))
 630 000a F040      		sbci r31,hi8(-(matrix))
 116:matrix.c      **** }
 631               		.loc 1 116 0
 632 000c 8081      		ld r24,Z
 633 000e 9181      		ldd r25,Z+1
 634               	.LVL24:
 635 0010 0895      		ret
 636               		.cfi_endproc
 637               	.LFE13:
 639               		.section	.text.matrix_print,"ax",@progbits
 640               	.global	matrix_print
 642               	matrix_print:
 643               	.LFB14:
 119:matrix.c      **** {
 644               		.loc 1 119 0
 645               		.cfi_startproc
 646 0000 CF92      		push r12
 647               	.LCFI14:
 648               		.cfi_def_cfa_offset 3
 649               		.cfi_offset 12, -2
 650 0002 DF92      		push r13
 651               	.LCFI15:
 652               		.cfi_def_cfa_offset 4
 653               		.cfi_offset 13, -3
 654 0004 EF92      		push r14
 655               	.LCFI16:
 656               		.cfi_def_cfa_offset 5
 657               		.cfi_offset 14, -4
 658 0006 FF92      		push r15
 659               	.LCFI17:
 660               		.cfi_def_cfa_offset 6
 661               		.cfi_offset 15, -5
 662 0008 0F93      		push r16
 663               	.LCFI18:
 664               		.cfi_def_cfa_offset 7
 665               		.cfi_offset 16, -6
 666 000a 1F93      		push r17
 667               	.LCFI19:
 668               		.cfi_def_cfa_offset 8
 669               		.cfi_offset 17, -7
 670 000c CF93      		push r28
 671               	.LCFI20:
 672               		.cfi_def_cfa_offset 9
 673               		.cfi_offset 28, -8
 674 000e DF93      		push r29
 675               	.LCFI21:
 676               		.cfi_def_cfa_offset 10
 677               		.cfi_offset 29, -9
 678               	/* prologue: function */
 679               	/* frame size = 0 */
 680               	/* stack size = 8 */
 681               	.L__stack_usage = 8
 120:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 682               		.loc 1 120 0
 683 0010 80E0      		ldi r24,lo8(__c.1915)
 684 0012 90E0      		ldi r25,hi8(__c.1915)
 685 0014 0E94 0000 		call xputs
 686 0018 C0E0      		ldi r28,lo8(matrix)
 687 001a EC2E      		mov r14,r28
 688 001c C0E0      		ldi r28,hi8(matrix)
 689 001e FC2E      		mov r15,r28
 690 0020 C0E0      		ldi r28,0
 691 0022 D0E0      		ldi r29,0
 692               	.LBB53:
 122:matrix.c      ****         phex(row); print(": ");
 693               		.loc 1 122 0
 694 0024 10E0      		ldi r17,lo8(__c.1918)
 695 0026 C12E      		mov r12,r17
 696 0028 10E0      		ldi r17,hi8(__c.1918)
 697 002a D12E      		mov r13,r17
 123:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 698               		.loc 1 123 0
 699 002c 00E0      		ldi r16,lo8(__c.1922)
 700 002e 10E0      		ldi r17,hi8(__c.1922)
 701               	.L63:
 122:matrix.c      ****         phex(row); print(": ");
 702               		.loc 1 122 0 discriminator 2
 703 0030 DF93      		push r29
 704               	.LCFI22:
 705               		.cfi_def_cfa_offset 11
 706 0032 CF93      		push r28
 707               	.LCFI23:
 708               		.cfi_def_cfa_offset 12
 709 0034 DF92      		push r13
 710               	.LCFI24:
 711               		.cfi_def_cfa_offset 13
 712 0036 CF92      		push r12
 713               	.LCFI25:
 714               		.cfi_def_cfa_offset 14
 715 0038 0E94 0000 		call __xprintf
 716 003c 80E0      		ldi r24,lo8(__c.1920)
 717 003e 90E0      		ldi r25,hi8(__c.1920)
 718 0040 0E94 0000 		call xputs
 123:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 719               		.loc 1 123 0 discriminator 2
 720 0044 F701      		movw r30,r14
 721 0046 8191      		ld r24,Z+
 722 0048 9191      		ld r25,Z+
 723 004a 7F01      		movw r14,r30
 724 004c 0E94 0000 		call bitrev16
 725 0050 9F93      		push r25
 726               	.LCFI26:
 727               		.cfi_def_cfa_offset 15
 728 0052 8F93      		push r24
 729               	.LCFI27:
 730               		.cfi_def_cfa_offset 16
 731 0054 1F93      		push r17
 732               	.LCFI28:
 733               		.cfi_def_cfa_offset 17
 734 0056 0F93      		push r16
 735               	.LCFI29:
 736               		.cfi_def_cfa_offset 18
 737 0058 0E94 0000 		call __xprintf
 124:matrix.c      ****         print("\n");
 738               		.loc 1 124 0 discriminator 2
 739 005c 80E0      		ldi r24,lo8(__c.1924)
 740 005e 90E0      		ldi r25,hi8(__c.1924)
 741 0060 0E94 0000 		call xputs
 742 0064 2196      		adiw r28,1
 121:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 743               		.loc 1 121 0 discriminator 2
 744 0066 8DB7      		in r24,__SP_L__
 745 0068 9EB7      		in r25,__SP_H__
 746 006a 0896      		adiw r24,8
 747 006c 0FB6      		in __tmp_reg__,__SREG__
 748 006e F894      		cli
 749 0070 9EBF      		out __SP_H__,r25
 750 0072 0FBE      		out __SREG__,__tmp_reg__
 751 0074 8DBF      		out __SP_L__,r24
 752               	.LCFI30:
 753               		.cfi_def_cfa_offset 10
 754 0076 C430      		cpi r28,4
 755 0078 D105      		cpc r29,__zero_reg__
 756 007a 01F4      		brne .L63
 757               	/* epilogue start */
 758               	.LBE53:
 126:matrix.c      **** }
 759               		.loc 1 126 0
 760 007c DF91      		pop r29
 761 007e CF91      		pop r28
 762 0080 1F91      		pop r17
 763 0082 0F91      		pop r16
 764 0084 FF90      		pop r15
 765 0086 EF90      		pop r14
 766 0088 DF90      		pop r13
 767 008a CF90      		pop r12
 768 008c 0895      		ret
 769               		.cfi_endproc
 770               	.LFE14:
 772               		.section	.text.matrix_key_count,"ax",@progbits
 773               	.global	matrix_key_count
 775               	matrix_key_count:
 776               	.LFB15:
 129:matrix.c      **** {
 777               		.loc 1 129 0
 778               		.cfi_startproc
 779 0000 1F93      		push r17
 780               	.LCFI31:
 781               		.cfi_def_cfa_offset 3
 782               		.cfi_offset 17, -2
 783 0002 CF93      		push r28
 784               	.LCFI32:
 785               		.cfi_def_cfa_offset 4
 786               		.cfi_offset 28, -3
 787 0004 DF93      		push r29
 788               	.LCFI33:
 789               		.cfi_def_cfa_offset 5
 790               		.cfi_offset 29, -4
 791               	/* prologue: function */
 792               	/* frame size = 0 */
 793               	/* stack size = 3 */
 794               	.L__stack_usage = 3
 795               	.LVL25:
 796 0006 C0E0      		ldi r28,lo8(matrix)
 797 0008 D0E0      		ldi r29,hi8(matrix)
 130:matrix.c      ****     uint8_t count = 0;
 798               		.loc 1 130 0
 799 000a 10E0      		ldi r17,0
 800               	.LVL26:
 801               	.L66:
 802               	.LBB54:
 132:matrix.c      ****         count += bitpop16(matrix[i]);
 803               		.loc 1 132 0 discriminator 2
 804 000c 8991      		ld r24,Y+
 805 000e 9991      		ld r25,Y+
 806 0010 0E94 0000 		call bitpop16
 807               	.LVL27:
 808 0014 180F      		add r17,r24
 809               	.LVL28:
 131:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 810               		.loc 1 131 0 discriminator 2
 811 0016 80E0      		ldi r24,hi8(matrix+8)
 812 0018 C030      		cpi r28,lo8(matrix+8)
 813 001a D807      		cpc r29,r24
 814 001c 01F4      		brne .L66
 815               	.LBE54:
 135:matrix.c      **** }
 816               		.loc 1 135 0
 817 001e 812F      		mov r24,r17
 818               	/* epilogue start */
 819 0020 DF91      		pop r29
 820 0022 CF91      		pop r28
 821 0024 1F91      		pop r17
 822               	.LVL29:
 823 0026 0895      		ret
 824               		.cfi_endproc
 825               	.LFE15:
 827               		.section	.progmem.data,"a",@progbits
 830               	__c.1924:
 831 0000 0A00      		.string	"\n"
 834               	__c.1922:
 835 0002 2530 3136 		.string	"%016b"
 835      6200 
 838               	__c.1920:
 839 0008 3A20 00   		.string	": "
 842               	__c.1918:
 843 000b 2530 3258 		.string	"%02X"
 843      00
 846               	__c.1915:
 847 0010 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 847      2030 3132 
 847      3334 3536 
 847      3738 3941 
 847      4243 4445 
 850               	__c.1893:
 851 0027 0A00      		.string	"\n"
 854               	__c.1891:
 855 0029 2530 3258 		.string	"%02X"
 855      00
 858               	__c.1889:
 859 002e 626F 756E 		.string	"bounce!: "
 859      6365 213A 
 859      2000 
 860               	.global	rows
 861               		.data
 864               	rows:
 865 0000 0000      		.word	0
 866 0002 0100      		.word	1
 867 0004 0300      		.word	3
 868 0006 0200      		.word	2
 869               		.local	matrix_debouncing
 870               		.comm	matrix_debouncing,8,1
 871               		.local	matrix
 872               		.comm	matrix,8,1
 875               	debouncing:
 876 0008 05        		.byte	5
 877               		.comm	debug_config,1,1
 878               		.text
 879               	.Letext0:
 880               		.file 3 "/usr/lib/avr/include/stdint.h"
 881               		.file 4 "../../common/debug_config.h"
 882               		.file 5 "../../common/matrix.h"
 883               		.file 6 "../../common/xprintf.h"
 884               		.file 7 "../../common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccEmJg4w.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccEmJg4w.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccEmJg4w.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccEmJg4w.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccEmJg4w.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccEmJg4w.s:12     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccEmJg4w.s:36     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccEmJg4w.s:53     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccEmJg4w.s:70     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccEmJg4w.s:870    .bss:0000000000000008 matrix
                             .bss:0000000000000000 matrix_debouncing
     /tmp/ccEmJg4w.s:138    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccEmJg4w.s:854    .progmem.data:0000000000000029 __c.1891
     /tmp/ccEmJg4w.s:875    .data:0000000000000008 debouncing
                            *COM*:0000000000000001 debug_config
     /tmp/ccEmJg4w.s:858    .progmem.data:000000000000002e __c.1889
     /tmp/ccEmJg4w.s:850    .progmem.data:0000000000000027 __c.1893
     /tmp/ccEmJg4w.s:550    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccEmJg4w.s:572    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccEmJg4w.s:615    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccEmJg4w.s:642    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccEmJg4w.s:846    .progmem.data:0000000000000010 __c.1915
     /tmp/ccEmJg4w.s:842    .progmem.data:000000000000000b __c.1918
     /tmp/ccEmJg4w.s:834    .progmem.data:0000000000000002 __c.1922
     /tmp/ccEmJg4w.s:838    .progmem.data:0000000000000008 __c.1920
     /tmp/ccEmJg4w.s:830    .progmem.data:0000000000000000 __c.1924
     /tmp/ccEmJg4w.s:775    .text.matrix_key_count:0000000000000000 matrix_key_count
     /tmp/ccEmJg4w.s:864    .data:0000000000000000 rows

UNDEFINED SYMBOLS
xputs
__xprintf
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
